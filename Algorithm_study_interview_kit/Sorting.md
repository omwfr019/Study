Sorting
=========

### 정렬의 종류

#### 시간복잡도 비교
|이름|최선|평균|최악|
|----|----|----|----|
|삽입정렬|n|n^2|n^2|
|선택정렬|n^2|n^2|n^2|
|버블정렬|n^2|n^2|n^2|
|셸 정렬|n|n^1.5|n^2|
|퀵 정렬|nlog2n|nlog2n|n^2|
|힙 정렬|nlog2n|nlog2n|nlog2n|
|병합정렬|nlog2n|nlog2n|nlog2n|

<br/>

---

<br/>

## Bubble Sort (버블 정렬)
: 인접한 두 원소를 검사하여 큰 수를 뒤로 보내 정렬. ex) 1-2, 2-3, 3-4, ...
* 1회전을 수행하면 가장 큰 요소가 맨 뒤로 이동 (다음 회전에선 맨 끝 요소를 정렬에서 제외)
* 시간복잡도 : O(n^2)
  + 최선 : 이미 정렬된 원소들이 주어짐 => 자리교환 없음 = O(n) 비교, O(1) 교환
  + 평균/최악 : n-1, n-2, ..., 2, 1번 = (n-1)+(n-2)+...+2+1 = (n-1)* n/2 = n(n-1)/2 => O(n^2) 비교, O(n^2) 교환
* 장점
  + 구현이 간단
* 단점
  + 순서에 맞지 않은 요소도 인접한 요소와 교환
  + 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 함
  + 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환 발생

> 0 - 3 5 9 1 7 <br/>
> 1 - 3 5 1 7 9 <br/>
> 2 - 3 1 5 7 9 <br/>
> 3 - 1 3 5 7 9 <br/>

<br/>

1. 정렬할 배열 요소의 개수만큼 반복. 단, 마지막 요소는 다음 요소와 비교할 필요 없으므로 배열의 length에서 1을 빼줌.
2. 1번 과정의 반복이 1회 수행될 때 (1회전), 인접한 요소와 비교할 횟수만큼 반복. <br/>
   단, 1번 과정이 1회 수행되면 제일 뒷자리의 수는 정렬이 완료(자리 고정)되었으므로 비교 필요 없음 ~> 1번 수행 횟수를 빼줌.
3. 인접한 2개의 요소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환

<br/>

만약, 중간에 정렬이 완료되더라도 버블 정렬은 나머지 모든 원소를 비교함. <br/>
따라서 정렬이 끝났을 경우 다음 과정(비교)을 중단하면, 비교 횟수를 줄여 시간복잡도 개선 가능. <br/>
=> n회전일 때 swap이 이루어졌는지 체크하고, swap이 이루어지지 않았으면 이미 정렬이 완료되었다고 판단. <br/>

``` java
void bubbleSort(int[] arr) {
  for(int i=0; i<arr.length-1; i++) {
    boolean chkSwap = false; // 시간복잡도 개선
    
    for(int j=1; j<arr.length-i; j++) {
      if(arr[j] < arr[j-1]) {
        int temp = arr[j-1];
        arr[j-1] = arr[j];
        arr[j] = temp;

        chkSwap = true;
      }
    }
    if(!chkSwap) break;
  }
}
```

<br/><br/>

### 분할 정복 알고리즘
1. 분할
   + 문제를 작은 단위로 나눔 (내용은 동일. 크기만 작아짐)
2. 정복
   + 각각의 작은 문제를 해결
3. 합병
   + 해결된 작은 문제를 합merge하여 원래 문제의 답을 구함

<br/>

## Meege Sort (합병 정렬)

* 분할 정복 알고리즘 사용
* recursion 이용하여 구현
* 배열을 계속 반으로 나눔 ~> 결국 하나의 원소를 갖게됨 => 이때 각각은 정렬된 리스트 <br/>
  위 상태를 다시 merge
* 두 배열을 합칠 추가 배열 필요

#### 시간복잡도 : O(nlog2(n))
* 분할 단계 : 비교 연산, 이동 연산이 수행되지 않음 <br/>
  합병 단계
  + 크기 n/2인 부분 배열 1쌍 * n번 비교
  + 크기 n/4인 부분 배열 2쌍 * (n/2)번 비교
  + ...
  + 크기 1인 부분 배열 (n/2)쌍 * 2번 비교
* n개 데이터를 정렬하는 시간 = T(n) <br/>
  n을 반으로 나누어 정렬하는 시간 = T(n/2) <br/>
  => 2 * (n/2) = n
* 나누어진 배열을 병합할 때의 시간은 n을 넘지 않음 <br/>
  길이가 n인 배열을 길이가 1인 각각의 리스트로 나누면, 트리의 레벨은 logn <br/>
  분할 과정은 매번 반씩 감소하므로 밑이 2인 logn만큼 반복 <br/>
  => logn
* 비교 연산의 총 횟수= n * log2(n)

<br/>

1. 배열을 반으로 나눔 (리스트의 길이가 1이 될 때까지 순환) => 분할 <br/>
  1.1. 중간 인덱스를 구함 <br/>
  1.2. 나누어진 두 배열이 같은 값을 가지면(하나의 원소만 남으면) 종료
2. 각각의 배열을 정렬 => 정복
3. 각 배열을 비교하여 가장 작은 값부터 차례대로 새로운 배열에 저장 => 합병

``` java
void partition(int ary[], int start, int end) {
  if(start == end) return;
  
  int mid = (start + end) / 2;
  partition(start, mid);
  partition(mid+1, end);
  merge(ary, start, mid, end);
}

void merge(int ary[], int start, int mid, int end) {
  int temp[] = new int[ary.length];
  int mid = (start + end) / 2;
  int i = start;
  int j = mid + 1;
  int k = start;
  
  while(i <= mid && j <= end) {
    if(ary[i] < ary[j]) {
      temp[k] = ary[i];
      i++;
    } else {
      temp[k] = ary[j];
      j++;
    }
    k++;
    
    // temp[k++] = ary[i] < ary[j] ? ary[i++] : ary[j++];
  }
  
  if(i > mid) {
    for(int n=j; n<=end; n++) {
      temp[k] = ary[n];
      k++;
    }
  }
  else {
    for(int n=i; n<=mid; n++) {
      temp[k] = ary[n];
      k++;
    }
  }
  
  for(int n=startl n<=end; n++) {
    ary[n] = tmp[n];
  }
}

```

<br/>

## Quick Sort (퀵 정렬)

: 하나의 리스트를 피벗pivot을 기준으로 분할하고, 분할된 부분 리스트를 정렬하고 다시 합침.

* 분할 정복 알고리즘 사용
* 불안정 정렬. 수행 속도 매우 빠름
* 합병 정렬과 달리 리스트를 비균등하게 분할

1. 리스트 안에서 요소 선택 (피벗pivot)
2. 피벗을 기준으로 피벗보다 작은 요소들은 피벗의 왼쪽으로, 큰 요소들은 피벗의 오른쪽으로 옮김
3. 피벗을 제외한 왼쪽/오른쪽 리스트 정렬
4. 위 과정을 부분 리스트들이 분할 불가능할 때가지 반복

``` java

```
