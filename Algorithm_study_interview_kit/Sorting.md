Sorting
=========

### 정렬의 종류

#### 시간복잡도 비교
|이름|최선|평균|최악|
|----|----|----|----|
|삽입정렬|n|n^2|n^2|
|선택정렬|n^2|n^2|n^2|
|버블정렬|n^2|n^2|n^2|
|셸 정렬|n|n^1.5|n^2|
|퀵 정렬|nlog2n|nlog2n|n^2|
|힙 정렬|nlog2n|nlog2n|nlog2n|
|병합정렬|nlog2n|nlog2n|nlog2n|

<br/><br/>

---

<br/>

## Bubble Sort (버블 정렬)
: 인접한 두 원소를 검사하여 큰 수를 뒤로 보내 정렬. ex) 1-2, 2-3, 3-4, ...
* 1회전을 수행하면 가장 큰 요소가 맨 뒤로 이동 (다음 회전에선 맨 끝 요소를 정렬에서 제외)
* 시간복잡도 : O(n^2)
  + 최선 : 이미 정렬된 원소들이 주어짐 => 자리교환 없음 = O(n) 비교, O(1) 교환
  + 평균/최악 : n-1, n-2, ..., 2, 1번 = (n-1)+(n-2)+...+2+1 = (n-1)* n/2 = n(n-1)/2 => O(n^2) 비교, O(n^2) 교환
* 장점
  + 구현이 간단
* 단점
  + 순서에 맞지 않은 요소도 인접한 요소와 교환
  + 하나의 요소가 가장 왼쪽에서 가장 오른쪽으로 이동하기 위해서는 배열에서 모든 다른 요소들과 교환되어야 함
  + 특정 요소가 최종 정렬 위치에 이미 있는 경우라도 교환 발생

> 0 - 3 5 9 1 7 <br/>
> 1 - 3 5 1 7 9 <br/>
> 2 - 3 1 5 7 9 <br/>
> 3 - 1 3 5 7 9 <br/>

<br/>

1. 정렬할 배열 요소의 개수만큼 반복. 단, 마지막 요소는 다음 요소와 비교할 필요 없으므로 배열의 length에서 1을 빼줌.
2. 1번 과정의 반복이 1회 수행될 때, 인접한 요소와 비교할 횟수만큼 반복. <br/>
   단, 1번 과정이 1회 수행되면 제일 뒷자리의 수는 정렬이 완료(자리 고정)되었으므로 비교 필요 없음 ~> 1번 수행 횟수를 빼줌.
3. 인접한 2개의 요소를 비교하여 크기가 순서대로 되어 있지 않으면 서로 교환

``` java
void bubbleSort(int[] arr) {
  for(int i=0;  i<arr.length-1; i++) {
    for(int j=1; j<arr.length-i; j++) {
      if(arr[j] < arr[j-1]) {
        int temp = arr[j-1];
        arr[j-1] = arr[j];
        arr[j] = temp;
      }
    }
  }
}
```
